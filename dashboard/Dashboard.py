# -*- coding: utf-8 -*-
"""Thoriq_Proyek Analisis Data E-Commerce di Brazil.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hOWIbVdFxPmH0QN4ByneuV5xRhZNrdq9

# Proyek Analisis Data: E-Commerce Public Dataset
- **Nama:** Mohamad Thoriq Abdurachman
- **Email:** mohamadthoriq09@gmail.com
- **ID Dicoding:** thoriq09

## Menentukan Pertanyaan Bisnis

- Apa kategori produk dengan penjualan tertinggi berdasarkan jumlah item yang terjual?
- Apa pola ulasan pelanggan terhadap pesanan dengan nilai bintang rendah?
- Siapa saja penjual dengan performa terbaik berdasarkan jumlah penjualan?

## Import Semua Packages/Library yang Digunakan
"""

# ! pip install -r requirements.txt

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.cluster import KMeans
import seaborn as sns
import geopandas as gpd
from geopandas.tools import geocode
import folium
from datetime import datetime
import streamlit as st
from wordcloud import WordCloud
import plotly.express as px

# """## Data Wrangling

# ### Gathering Data
# """

# order_items_df = pd.read_csv ("dataset/order_items_dataset.csv")
# order_items_df.head()

# """**Fungsi:**
# Berisi rincian barang yang dipesan.
# """

# products_df = pd.read_csv ("dataset/products_dataset.csv")
# products_df.head()

# """**Fungsi:**
# Menyediakan informasi produk.
# """

# reviews_df = pd.read_csv ("dataset/order_reviews_dataset.csv")
# reviews_df.head()

# """**Fungsi:**
# Berisi ulasan pelanggan.
# """

# sellers_df = pd.read_csv ("dataset/sellers_dataset.csv")
# sellers_df.head()

# """**Fungsi:**
# Berisi informasi penjual.
# """

# orders_df = pd.read_csv ("dataset/orders_dataset.csv")
# orders_df.head()

# """**Fungsi:**
# Berisi informasi terkait pesanan.
# """

# geoloc_df = pd.read_csv ("dataset/geolocation_dataset.csv")
# geoloc_df.head()

# """**Fungsi:**
# Berisi data lokasi geografis.
# """

# customers_df = pd.read_csv ("dataset/customers_dataset.csv")
# customers_df.head()

# """**Fungsi:**
# Berisi informasi pelanggan.
# """

# payments_df = pd.read_csv ("dataset/order_payments_dataset.csv")
# payments_df.head()

# """**Fungsi:**
# Berisi detail pembayaran.

# ### Assessing Data

# ####Menilai Tabel order_items_df
# """

# print("Informasi Tabel:")
# print(order_items_df.info())
# print("\nStatistik Deskriptif:")
# print(order_items_df.describe())
# print("\nJumlah Nilai Kosong:")
# print(order_items_df.isnull().sum())
# print("\nJumlah Baris Duplikat:")
# print(order_items_df.duplicated().sum())
# print("\nMengecek Harga Negatif (Kurang Dari 0):")
# print(order_items_df[order_items_df['price'] < 0])
# print("\nVisualisasi Outlier Kolom 'price':")
# sns.boxplot(data=order_items_df, x='price')
# plt.title("Boxplot Harga")
# plt.show()

# """**Insight:**
# - Tidak ada nilai kosong.
# - Tidak ada duplikasi data.
# - Tidak ada harga bernilai negatif.
# - Menunjukkan potensi outlier, karena harga produk memiliki nilai maksimum yang sangat tinggi dan melebihi nilai pada kuartil tiga. Selain itu, biaya pengiriman juga memiliki nilai maksimum yang sangat tinggi dan melebihi nilai pada kuartil tiga.

# ####Menilai Tabel products_df
# """

# print("Informasi Tabel:")
# print(products_df.info())
# print("\nJumlah Nilai Kosong:")
# print(products_df.isnull().sum())
# print("\nJumlah Baris Duplikat:")
# print(products_df.duplicated().sum())
# print("\nKategori Produk Unik:")
# print("Jumlah =", products_df['product_category_name'].nunique())
# print(products_df['product_category_name'].unique())

# """**Insight:**
# - Terdapat kolom yang memiliki nilai kosong.
# - Tidak ada duplikasi data.
# - Terdapat nilai nan pada kategori produk.

# ####Menilai Tabel reviews_df
# """

# print("Informasi Tabel:")
# print(reviews_df.info())
# print("\nJumlah Nilai Kosong:")
# print(reviews_df.isnull().sum())
# print("\nJumlah Baris Duplikat:")
# print(reviews_df.duplicated().sum())
# print("\nStatistik Skor Ulasan:")
# print(reviews_df['review_score'].describe())
# print("\nVisualisasi Penyebaran Skor Ulasan:")
# sns.histplot(reviews_df['review_score'], bins=5, kde=False)
# plt.title("Penyebaran Skor Ulasan")
# plt.xlabel("Skor")
# plt.ylabel("Frekuensi")
# plt.show()

# """**Insight:**
# - Terdapat kolom dengan nilai kosong yang jumlahnya cukup banyak.
# - Tidak ada duplikasi data.
# - Skor ulasan yang cenderung tinggi menunjukkan adanya kemungkinan bias data.

# ####Menilai Tabel sellers_df
# """

# print("Informasi Tabel:")
# print(sellers_df.info())
# print("\nJumlah Nilai Kosong:")
# print(sellers_df.isnull().sum())
# print("\nJumlah Baris Duplikat:")
# print(sellers_df.duplicated().sum())
# print("\nValidasi Lokasi Penjual:")
# print("Jumlah =", sellers_df['seller_zip_code_prefix'].nunique())
# print(sellers_df['seller_zip_code_prefix'].unique())

# """**Insight:**
# - Tidak ada kolom dengan nilai kosong.
# - Tidak ada duplikasi data.
# - Banyaknya jumlah lokasi penjual menunjukkan distribusi lokasi penjual yang beragam.
# - Tabel sudah bersih dan dapat digunakan.

# ####Menilai Tabel orders_df
# """

# print("Informasi Tabel:")
# print(orders_df.info())
# print("\nJumlah Nilai Kosong:")
# print(orders_df.isnull().sum())
# print("\nJumlah Baris Duplikat:")
# print(orders_df.duplicated().sum())
# print("\nValidasi Status Pesanan:")
# print("Jumlah =", orders_df['order_status'].nunique())
# print(orders_df['order_status'].unique())

# """**Insight:**
# - Terdapat kolom dengan nilai kosong.
# - Tidak ada dupilkasi data.
# - Terdapat 8 kategori status pesanan.

# ####Menilai Tabel geoloc_df
# """

# print("Informasi Tabel:")
# print(geoloc_df.info())
# print("\nJumlah Nilai Kosong:")
# print(geoloc_df.isnull().sum())
# print("\nJumlah Baris Duplikat:")
# print(geoloc_df.duplicated().sum())
# print("\nValidasi Kode Pos Unik:")
# print("Jumlah =", geoloc_df['geolocation_zip_code_prefix'].nunique())
# print(geoloc_df['geolocation_zip_code_prefix'].unique())

# """**Insight:**
# - Tidak ada kolom dengan nilai kosong.
# - Terdapat duplikasi data berdasarkan semua kolom.

# ####Menilai Tabel customers_df
# """

# print("Informasi Tabel:")
# print(customers_df.info())
# print("\nJumlah Nilai Kosong:")
# print(customers_df.isnull().sum())
# print("\nJumlah Baris Duplikat:")
# print(customers_df.duplicated().sum())
# print("\nValidasi ID Pelanggan:")
# print("Jumlah =", customers_df['customer_id'].nunique())
# print(customers_df['customer_id'].unique())

# """**Insight:**
# - Tidak terdapat kolom dengan nilai kosong.
# - Tidak ada dupilkasi data.
# - Tabel sudah bersih dan dapat digunakan.

# ####Menilai Tabel payments_df
# """

# print("Informasi Tabel:")
# print(payments_df.info())
# print("\nJumlah Nilai Kosong:")
# print(payments_df.isnull().sum())
# print("\nJumlah Baris Duplikat:")
# print(payments_df.duplicated().sum())
# print("\nStatistik Jumlah Pembayaran:")
# print(payments_df['payment_value'].describe())
# print("\nVisualisasi Penyebaran Nilai Pembayaran:")
# sns.histplot(payments_df['payment_value'], kde=True)
# plt.title("Penyebaran Nilai Pembayaran")
# plt.xlabel("Nilai Pembayaran")
# plt.ylabel("Frekuensi")
# plt.show()

# """**Insight:**
# - Tidak terdapat kolom dengan nilai kosong.
# - Tidak ada dupilkasi data.
# - Menunjukkan potensi outlier, karena kolom 'payment_value' memiliki nilai maksimum yang sangat tinggi dan melebihi nilai pada kuartil tiga.

# ### Cleaning Data

# ####Membersihkan Tabel order_items_df
# """

# #Mengatasi Potensi Outlier
# Q1_price = order_items_df['price'].quantile(0.25)
# Q3_price = order_items_df['price'].quantile(0.75)
# IQR_price = Q3_price - Q1_price

# Q1_fr = order_items_df['freight_value'].quantile(0.25)
# Q3_fr = order_items_df['freight_value'].quantile(0.75)
# IQR_fr = Q3_fr - Q1_fr

# #Filter Outlier
# cleaned_order_items_df = order_items_df[
#     (order_items_df['price'] >= (Q1_price - 1.5 * IQR_price)) &
#     (order_items_df['price'] <= (Q3_price + 1.5 * IQR_price)) &
#     (order_items_df['freight_value'] >= (Q1_fr - 1.5 * IQR_fr)) &
#     (order_items_df['freight_value'] <= (Q3_fr + 1.5 * IQR_fr))
# ]

# print("Statistik Deskriptif Setelah Dibersihkan:")
# cleaned_order_items_df.describe()

# """**Insight:**
# Membersihkan outlier yang ada pada kolom 'price' dan 'freight_value'.

# ####Membersihkan Tabel products_df
# """

# #Menyalin DataFrame
# cleaned_products_df = products_df.copy()

# # Mengisi Nilai Kosong
# if 'product_category_name' in cleaned_products_df.columns:
#     cleaned_products_df['product_category_name'] = cleaned_products_df['product_category_name'].fillna('unknown')

# cleaned_products_df[['product_name_lenght', 'product_description_lenght', 'product_photos_qty']] = cleaned_products_df[['product_name_lenght', 'product_description_lenght', 'product_photos_qty']].fillna(0)

# # Menghapus Baris dengan Nilai Kosong pada Kolom Ukuran Produk
# important_columns = ['product_weight_g', 'product_length_cm', 'product_height_cm', 'product_width_cm']
# cleaned_products_df = cleaned_products_df.dropna(subset=important_columns)
# cleaned_products_df

# print(cleaned_products_df.head())
# print("\nJumlah Nilai Kosong Setelah Pembersihan:")
# print(cleaned_products_df.isna().sum())
# print("\nKategori Produk Unik Setelah Pembersihan:")
# print("Jumlah =", cleaned_products_df['product_category_name'].nunique())
# print(cleaned_products_df['product_category_name'].unique())

# """**Insight:**
# - Nilai kosong pada kolom kategori diisi dengan 'unknown'.
# - Kolom dimensi produk yang kosong dihapus.

# ####Membersihkan Tabel reviews_df
# """

# #Menyalin DataFrame
# cleaned_reviews_df = reviews_df.copy()

# #Mengisi Nilai Kosong
# cleaned_reviews_df[['review_comment_title', 'review_comment_message']] = cleaned_reviews_df[['review_comment_title', 'review_comment_message']].fillna('')

# print(cleaned_reviews_df.head())
# print("\nJumlah Nilai Kosong Setelah Pembersihan:")
# print(cleaned_reviews_df.isna().sum())

# """**Insight:**
# Kolom ulasan yang kosong diisi dengan string kosong untuk menghindari kesalahan saat analisis data.

# ####Membersihkan Tabel orders_df
# """

# # Mengisi Nilai Kosong dengan Placeholder
# orders_df['order_status'] = orders_df['order_status'].fillna("unknown")

# # Mengubah Tipe Data dan Nilai pada Kolom Tanggal
# date_col = [
#     'order_purchase_timestamp',
#     'order_approved_at',
#     'order_delivered_carrier_date',
#     'order_delivered_customer_date',
#     'order_estimated_delivery_date'
# ]

# for col in date_col:
#     orders_df[col] = pd.to_datetime(orders_df[col], errors='coerce')  # Tipe Data Menjadi Datetime dan Nilai invalid Menjadi NaT
#     orders_df[col] = orders_df[col].fillna(pd.Timestamp("1970-01-01"))  # Ganti NaT dengan nilai default

# # Mengisi Nilai Kosong dengan Placeholder
# orders_df['order_id'] = orders_df['order_id'].fillna("unknown")
# orders_df['customer_id'] = orders_df['customer_id'].fillna("unknown")

# print("Data setelah cleaning:")
# print(orders_df)
# print(orders_df.info())
# print(orders_df.isna().sum())

# #Memastikan Data pada Tiap Status Tidak Terhapus
# for status in orders_df['order_status'].unique():
#     print(f"Contoh data untuk order_status: {status}")
#     print(orders_df[orders_df['order_status'] == status].head(), "\n")

# """**Insight:**
# Mengubah tipe data dengan tipe yang lebih sesuai dan mengisi nilai kosong pada tiap kolom dengan placeholder agar data dapat digunakan untuk analisis.

# ####Membersihkan Tabel geoloc_df
# """

# print("Memeriksa Baris Duplikat:")
# print(geoloc_df.duplicated())

# # Menambahkan Kolom 'frequency' untuk Menghitung Kemunculan Tiap Kombinasi Unik
# geoloc_df['frequency'] = geoloc_df.groupby(list(geoloc_df.columns)).transform('size')

# # Menghapus Baris Duplikasi
# geoloc_df = geoloc_df.drop_duplicates()

# print("\n Isi Tabel Setelah Dibersihkan:")
# print(geoloc_df.head())
# print("\nInformasi Tabel:")
# print(geoloc_df.info())
# print("\nJumlah Nilai Kosong:")
# print(geoloc_df.isnull().sum())
# print("\nJumlah Baris Duplikat:")
# print(geoloc_df.duplicated().sum())
# print("\nValidasi Kode Pos Unik:")
# print("Jumlah =", geoloc_df['geolocation_zip_code_prefix'].nunique())
# print(geoloc_df['geolocation_zip_code_prefix'].unique())

# """**Insight:**
# - Menambahkan kolom baru bernama 'frequency' untuk menghitung kemunculan tiap kombinasi unik.
# - Menghapus dupilkasi data.

# ####Membersihkan Tabel payments_df
# """

# #Mengatasi Potensi Outlier
# Q1_payment = payments_df['payment_value'].quantile(0.25)
# Q3_payment = payments_df['payment_value'].quantile(0.75)
# IQR_payment = Q3_payment - Q1_payment

# #Filter Outlier
# cleaned_payments_df = payments_df[
#     (payments_df['payment_value'] >= (Q1_payment - 1.5 * IQR_payment)) &
#     (payments_df['payment_value'] <= (Q3_payment + 1.5 * IQR_payment))
# ]

# print("Statistik Deskriptif Setelah Dibersihkan:")
# cleaned_payments_df.describe()

# print("\nVisualisasi Penyebaran Nilai Pembayaran Setelah Dibersihkan:")
# sns.histplot(cleaned_payments_df['payment_value'], kde=True)
# plt.title("Penyebaran Nilai Pembayaran")
# plt.xlabel("Nilai Pembayaran")
# plt.ylabel("Frekuensi")
# plt.show()

# """**Insight:**
# Membersihkan outlier yang ada pada kolom 'payment_value'.

# ## Exploratory Data Analysis (EDA)

# ### Explore Tabel order_items_df
# """

# # Menampilkan Informasi Awal Data
# print("Informasi Data:")
# print(cleaned_order_items_df.info())

# #Statistik Deskriptif
# print("\nStatistik Deskriptif:")
# print(cleaned_order_items_df.describe())

# # Statistik Kolom 'price' dan 'freight_value'
# print("\nStatistik Harga (price):")
# print(cleaned_order_items_df['price'].describe())
# print("\nStatistik Biaya Pengiriman (freight_value):")
# print(cleaned_order_items_df['freight_value'].describe())

# # Visualisasi Distribusi Harga
# plt.figure(figsize=(10, 6))
# sns.histplot(cleaned_order_items_df['price'], bins=30, kde=True)
# plt.title('Penyebaran Harga Barang dalam Pesanan')
# plt.xlabel('Harga')
# plt.ylabel('Frekuensi')
# plt.show()

# # Visualisasi Distribusi Biaya Pengiriman
# plt.figure(figsize=(10, 6))
# sns.histplot(cleaned_order_items_df['freight_value'], bins=30, kde=True, color='orange')
# plt.title('Penyebaran Biaya Pengiriman')
# plt.xlabel('Biaya Pengiriman')
# plt.ylabel('Frekuensi')
# plt.show()

# # Analisis Statistik Berdasarkan Produk
# product_stats = cleaned_order_items_df.groupby('product_id').agg({
#     'price': ['mean', 'max', 'min'],
#     'freight_value': 'mean'
# }).reset_index()
# product_stats.columns = ['product_id', 'avg_price', 'max_price', 'min_price', 'avg_freight']
# print("\nStatistik Berdasarkan Produk:\n", product_stats.head())

# # Top 10 Produk Berdasarkan Rata-rata Harga
# top_10_products = product_stats.sort_values('avg_price', ascending=False).head()
# print("\nTop 10 Produk dengan Harga Rata-Rata Tertinggi:\n", top_10_products)

# """**Insight:**
# - Barang yang dipesan didominasi dengan barang berharga rendah hingga menengah.
# - Barang dengan harga tinggi memiliki porsi kecil tetapi berpotensi menjadi target pasar khusus.
# - Produk dengan harga tinggi memiliki variasi biaya pengiriman yang signifikan, sehingga dapat dioptimalkan.

# ### Explore Tabel products_df
# """

# # Menampilkan Informasi Awal Data
# print("Informasi Data:")
# print(cleaned_products_df.info())

# #Statistik Deskriptif
# print(cleaned_products_df.describe())
# print(cleaned_products_df['product_category_name'].value_counts())

# #Visualisasi
# sns.countplot(data=cleaned_products_df, x='product_category_name', order=cleaned_products_df['product_category_name'].value_counts().index)
# plt.title('Jumlah Produk per Kategori')
# plt.xticks(rotation=90)
# plt.show()

# """**Insight:**
# - Terdapat beberapa nilai ekstrem (outliers) pada dimensi produk, yang mungkin disebabkan oleh kesalahan input data.
# - Beberapa kategori memiliki sangat sedikit produk
# - Ada kemungkinan toko online lebih fokus pada kategori tertentu, sedangkan kategori kecil perlu diperhatikan untuk pengembangan produk.

# ### Explore Tabel reviews_df
# """

# #Statistik Deskriptif
# print(cleaned_reviews_df['review_score'].describe())
# print(cleaned_reviews_df['review_score'].value_counts())

# #Visualisasi
# sns.countplot(data=cleaned_reviews_df, x='review_score', order=cleaned_reviews_df['review_score'].value_counts().index)
# plt.title('Penyebaran Skor Ulasan')
# plt.xlabel('SKor Ulasan')
# plt.ylabel('Jumlah')
# plt.show()

# #Word Cloud
# comment_txt = " ".join(review for review in cleaned_reviews_df['review_comment_message'].dropna())
# wordcloud = WordCloud(width=800, height=400, background_color='white').generate(comment_txt)
# plt.figure(figsize=(10, 5))
# plt.imshow(wordcloud, interpolation='bilinear')
# plt.axis('off')
# plt.show()

# # Analisis Panjang Komentar Ulasan
# cleaned_reviews_df['review_comment_length'] = cleaned_reviews_df['review_comment_message'].dropna().apply(len)

# #Statistik Deskriptif untuk Panjang Komentar
# print("\nDeskripsi Statistik untuk Panjang Komentar:")
# print(cleaned_reviews_df['review_comment_length'].describe())

# # Visualisasi Panjang Komentar
# sns.histplot(cleaned_reviews_df['review_comment_length'], bins=20, kde=True)
# plt.title('Distribusi Panjang Komentar Ulasan')
# plt.xlabel('Panjang Komentar')
# plt.ylabel('Frekuensi')
# plt.show()

# # Analisis Teks dengan Word Cloud (untuk Kolom review_comment_message)
# review_text = " ".join(comment for comment in cleaned_reviews_df['review_comment_message'].dropna())
# wordcloud = WordCloud(width=800, height=400, background_color='white', colormap='viridis').generate(review_text)

# plt.figure(figsize=(10, 5))
# plt.imshow(wordcloud, interpolation='bilinear')
# plt.axis('off')
# plt.title('Word Cloud untuk Komentar Ulasan')
# plt.show()

# # Analisis Hubungan Skor Ulasan dengan Panjang Komentar
# sns.boxplot(data=cleaned_reviews_df, x='review_score', y='review_comment_length')
# plt.title('Panjang Komentar Berdasarkan Skor Ulasan')
# plt.xlabel('Skor Ulasan')
# plt.ylabel('Panjang Komentar')
# plt.show()

# # Analisis Proporsi Komentar Kosong
# empty_comments = cleaned_reviews_df['review_comment_message'].isna().sum()
# total_reviews = len(cleaned_reviews_df)
# empty_comment_percentage = (empty_comments / total_reviews) * 100
# print(f"\nProporsi Komentar Kosong: {empty_comment_percentage:.2f}% ({empty_comments}/{total_reviews})")

# # Visualisasi Skor Ulasan untuk Komentar Kosong dan Tidak Kosong
# reviews_df['has_comment'] = reviews_df['review_comment_message'].notna()
# sns.countplot(
#     data=reviews_df,
#     x='review_score',
#     hue='has_comment',
#     order=reviews_df['review_score'].value_counts().index,
#     palette={False: 'red', True: 'green'}
# )
# plt.title('Penyebaran Skor Ulasan Berdasarkan Ketersediaan Komentar')
# plt.xlabel('Skor Ulasan')
# plt.ylabel('Jumlah')
# plt.legend(title='Komentar Tersedia', labels=['Tidak Ada', 'Ada'])
# plt.show()

# """**Insight:**
# - Sebagian besar pelanggan puas dengan produk atau layanan yang diberikan.
# - Ulasan negatif cenderung lebih informatif dan dapat digunakan untuk mengidentifikasi area perbaikan.

# ### Explore Tabel sellers_df
# """

# # Informasi Umum
# print("Informasi Umum Tabel sellers_df:")
# print(sellers_df.info())

# #Statistik Deskriptif
# print(sellers_df.describe())

# # Penyebaran Kode Pos Penjual
# print("\nPenyebaran Kode Pos Penjual:")
# print(sellers_df['seller_zip_code_prefix'].value_counts())

# sns.histplot(sellers_df['seller_zip_code_prefix'], bins=30, kde=False)
# plt.title('Penyebaran Kode Pos Penjual')
# plt.xlabel('Kode Pos')
# plt.ylabel('Jumlah Penjual')
# plt.show()

# # Penyebaran Penjual Berdasarkan Kota
# print("\nTop 10 Kota dengan Jumlah Penjual Terbanyak:")
# print(sellers_df['seller_city'].value_counts().head(10))

# sns.barplot(
#     y=sellers_df['seller_city'].value_counts().head(10).index,
#     x=sellers_df['seller_city'].value_counts().head(10),
#     palette="viridis"
# )
# plt.title('Top 10 Kota dengan Jumlah Penjual Terbanyak')
# plt.xlabel('Jumlah Penjual')
# plt.ylabel('Kota')
# plt.show()

# # Penyebaran Penjual Berdasarkan Provinsi
# print("\nPenyebaran Penjual Berdasarkan Provinsi:")
# print(sellers_df['seller_state'].value_counts())

# sns.countplot(data=sellers_df, y='seller_state', order=sellers_df['seller_state'].value_counts().index)
# plt.title('Penyebaran Penjual Berdasarkan Provinsi')
# plt.xlabel('Jumlah Penjual')
# plt.ylabel('Provinsi')
# plt.show()

# # Visualisasi Gabungan Kota dan Provinsi
# city_state = sellers_df.groupby(['seller_state', 'seller_city']).size().reset_index(name='count')
# top_city_state = city_state.sort_values(by='count', ascending=False).head(10)

# sns.barplot(data=top_city_state, x='count', y='seller_city', hue='seller_state', dodge=False)
# plt.title('Top 10 Kota dengan Penjual Terbanyak (per Provinsi)')
# plt.xlabel('Jumlah Penjual')
# plt.ylabel('Kota')
# plt.legend(title='Provinsi')
# plt.show()

# """**Insight:**
# - Distribusi kode pos menunjukkan bahwa sebagian besar penjual berada di lokasi spesifik dengan konsentrasi tinggi, meskipun ada penjual di wilayah yang lebih terpencil.
# - Penjual lebih terkonsentrasi di kota-kota besar yang cenderung menjadi pusat ekonomi (seperti São Paulo).
# - Provinsi dengan jumlah penjual rendah (seperti AC, MA, AM) dapat menjadi target potensial untuk memperluas jaringan distribusi.
# - Strategi bisnis dapat difokuskan pada kota besar seperti São Paulo, Curitiba, dan Rio de Janeiro untuk memaksimalkan peluang usaha.

# ### Explore Tabel orders_df
# """

# # Statistik Deskriptif
# print("Statistik Deskriptif untuk orders_df:")
# print(orders_df.describe())
# print("\nStatus Pesanan (Order Status):")
# print(orders_df['order_status'].value_counts())

# # Buat Kolom Tambahan
# orders_df['month'] = orders_df['order_purchase_timestamp'].dt.month
# orders_df['weekday'] = orders_df['order_purchase_timestamp'].dt.day_name()

# # Visualisasi Tren Pesanan Bulanan
# orders_monthly = orders_df.groupby('month')['order_id'].count()
# plt.figure(figsize=(10, 6))
# orders_monthly.plot(kind='line', marker='o')
# plt.title('Tren Jumlah Pesanan Bulanan')
# plt.xlabel('Bulan')
# plt.ylabel('Jumlah Pesanan')
# plt.xticks(ticks=range(1, 13), labels=['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
#                                        'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'])
# plt.grid(True)
# plt.show()

# # Visualisasi Penyebaran Status Pesanan
# plt.figure(figsize=(8, 5))
# sns.countplot(data=orders_df, x='order_status', order=orders_df['order_status'].value_counts().index, palette='Set2')
# plt.title('Penyebaran Status Pesanan')
# plt.xlabel('Status Pesanan')
# plt.ylabel('Jumlah')
# plt.xticks(rotation=90)
# plt.show()

# # Visualisasi Tren Pesanan per Hari dalam Seminggu
# orders_weekday = orders_df.groupby('weekday')['order_id'].count()
# plt.figure(figsize=(8, 5))
# orders_weekday.reindex(['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']).plot(kind='bar', color='orange')
# plt.title('Jumlah Pesanan Berdasarkan Hari dalam Seminggu')
# plt.xlabel('Hari')
# plt.ylabel('Jumlah Pesanan')
# plt.xticks(rotation=90)
# plt.show()

# # Memeriksa Nilai Null
# print("\nJumlah Nilai Null di Tabel orders_df:")
# print(orders_df.isnull().sum())

# # Analisis Waktu Pemesanan
# orders_df['hour'] = orders_df['order_purchase_timestamp'].dt.hour
# plt.figure(figsize=(10, 6))
# sns.histplot(orders_df['hour'], bins=24, kde=True, color='green')
# plt.title('Distribusi Waktu Pemesanan (Jam)')
# plt.xlabel('Jam')
# plt.ylabel('Frekuensi')
# plt.grid(True)
# plt.show()

# """**Insight:**
# - Tren musiman dapat digunakan untuk perencanaan stok dan pengelolaan logistik. Jika data menunjukkan puncak pesanan pada bulan tertentu, perusahaan dapat mempersiapkan inventaris atau promosi lebih baik di bulan tersebut.
# - Tingginya jumlah "delivered" menunjukkan efektivitas sistem pengiriman.
# - Dapat melakukan analisis lebih dalam mengenai alasan pembatalan (canceled) dan ketersediaan barang (unavailable) untuk meningkatkan kepuasan pelanggan.
# - Pesanan cenderung lebih tinggi pada hari tertentu dalam seminggu (misalnya, akhir pekan atau awal minggu kerja). Hal ini dapat membantu dalam strategi pemasaran seperti diskon atau promosi yang ditargetkan pada hari-hari dengan potensi pesanan yang lebih tinggi.
# - Sebagian besar pesanan dilakukan pada jam tertentu, mungkin pada jam kerja atau waktu senggang pelanggan. Hal ini dapat digunakan untuk mengoptimalkan kampanye iklan atau meningkatkan kapasitas dukungan pelanggan di jam-jam sibuk.

# ### Explore Tabel geoloc_df
# """

# # Statistik Deskriptif
# print("Statistik Deskriptif:")
# print(geoloc_df.describe())

# # Hitung Jumlah Unik Berdasarkan Kolom Provinsi
# print("\nJumlah Unik Lokasi per Provinsi:")
# print(geoloc_df['geolocation_state'].value_counts())

# # Visualisasi Distribusi Lokasi (Latitude dan Longitude)
# sns.scatterplot(data=geoloc_df, x='geolocation_lng', y='geolocation_lat', alpha=0.3, s=10)
# plt.title('Sebaran Geolokasi (Latitude dan Longitude)')
# plt.xlabel('Longitude')
# plt.ylabel('Latitude')
# plt.show()

# # Visualisasi Distribusi Jumlah Lokasi per Provinsi
# plt.figure(figsize=(10, 6))
# sns.countplot(data=geoloc_df, y='geolocation_state', order=geoloc_df['geolocation_state'].value_counts().index)
# plt.title('Jumlah Lokasi per Provinsi')
# plt.xlabel('Jumlah')
# plt.ylabel('Provinsi')
# plt.show()

# """**Insight:**
# - Penyebaran jumlah lokasi menunjukkan bahwa wilayah selatan dan tenggara Brasil (SP, MG, RJ) memiliki representasi data yang lebih besar dibandingkan wilayah utara.
# - Wilayah dengan representasi rendah dapat menjadi fokus untuk analisis lebih lanjut atau pengembangan jaringan logistik dan layanan.

# ### Explore Tabel customers_df
# """

# # Statistik Deskriptif
# print("Statistik Deskriptif:")
# print(customers_df.describe())

# # Cek distribusi lokasi pelanggan berdasarkan state
# print("\nDistribusi Lokasi Pelanggan (State):")
# print(customers_df['customer_state'].value_counts())

# # Visualisasi Distribusi Lokasi Pelanggan
# plt.figure(figsize=(12, 6))
# sns.countplot(data=customers_df, x='customer_state', order=customers_df['customer_state'].value_counts().index)
# plt.title('Distribusi Lokasi Pelanggan Berdasarkan State')
# plt.xticks(rotation=90)
# plt.xlabel('State')
# plt.ylabel('Jumlah Pelanggan')
# plt.show()

# """**Insight:**
# - Konsentrasi pelanggan terbesar berada di wilayah SP (São Paulo), yang merupakan pusat ekonomi Brasil. Hal ini bisa menjadi fokus utama untuk strategi pemasaran dan distribusi perusahaan.
# - State dengan pelanggan terbatas (seperti RR, AP, dan AC) menunjukkan peluang untuk ekspansi, tetapi mungkin perlu mempertimbangkan biaya dan infrastruktur yang ada di wilayah tersebut.

# ### Explore Tabel payments_df
# """

# # Statistik Deskriptif
# print("Statistik Deskriptif:")
# print(cleaned_payments_df.describe())

# # Informasi Data
# print("\nInformasi Data:")
# print(cleaned_payments_df.info())

# # Penyebaran Metode Pembayaran
# print("\nPenyebaran Metode Pembayaran:")
# print(cleaned_payments_df['payment_type'].value_counts())

# # Visualisasi Metode Pembayaran
# sns.countplot(data=cleaned_payments_df, x='payment_type', order=cleaned_payments_df['payment_type'].value_counts().index)
# plt.title('Penyebaran Metode Pembayaran')
# plt.xlabel('Metode Pembayaran')
# plt.ylabel('Jumlah')
# plt.xticks(rotation=90)
# plt.show()

# # Penyebaran Nilai Pembayaran
# sns.histplot(cleaned_payments_df['payment_value'], bins=20, kde=True)
# plt.title('Penyebaran Nilai Pembayaran')
# plt.xlabel('Nilai Pembayaran')
# plt.ylabel('Frekuensi')
# plt.show()

# # Visualisasi Outlier dengan Boxplot
# sns.boxplot(data=cleaned_payments_df, x='payment_type', y='payment_value')
# plt.title('Penyebaran Nilai Pembayaran Berdasarkan Metode Pembayaran')
# plt.xlabel('Metode Pembayaran')
# plt.ylabel('Nilai Pembayaran')
# plt.xticks(rotation=90)
# plt.show()

# # Grupkan rata-rata nilai pembayaran per metode pembayaran
# payment_method_avg = cleaned_payments_df.groupby('payment_type')['payment_value'].mean().reset_index()
# print("\nRata-rata Nilai Pembayaran per Metode Pembayaran:")
# print(payment_method_avg)

# # Visualisasi Rata-rata Nilai Pembayaran
# sns.barplot(data=payment_method_avg, x='payment_type', y='payment_value')
# plt.title('Rata-rata Nilai Pembayaran per Metode')
# plt.xlabel('Metode Pembayaran')
# plt.ylabel('Rata-rata Nilai Pembayaran')
# plt.xticks(rotation=90)
# plt.show()

# """**Insight:**
# - Mayoritas transaksi menggunakan metode credit card (73%) yang menunjukkan preferensi konsumen terhadap metode pembayaran yang cepat dan fleksibel.
# - Metode seperti voucher (6%) dan debit card (1.5%) jauh lebih jarang digunakan.
# - Nilai pembayaran 0 dapat menjadi indikasi data tidak valid atau transaksi khusus seperti promo.

# ## Visualization & Explanatory Analysis

# ### Pertanyaan 1: Apa kategori produk dengan penjualan tertinggi berdasarkan jumlah item yang terjual?
# """

# product_sales = cleaned_order_items_df.merge(cleaned_products_df, on='product_id')
# category_sales = product_sales.groupby('product_category_name')['order_item_id'].sum().sort_values(ascending=False)

# # Menampilkan Kategori dengan Penjualan Tertinggi
# plt.figure(figsize=(14, 8))
# category_sales.head(10).plot(kind='bar', color='skyblue')
# plt.title('Top 10 Kategori Produk dengan Penjualan Tertinggi')
# plt.xlabel('Kategori Produk')
# plt.ylabel('Total Jumlah Item Terjual')
# plt.xticks(rotation=45)
# plt.yticks()
# plt.grid(axis='y', linestyle='--', alpha=0.7)
# plt.tight_layout()
# plt.show()

# top_categories = category_sales.head(10).reset_index()
# top_categories.columns = ['Kategori Produk', 'Total Item Terjual']

# print("Top 10 Kategori Produk dengan Penjualan Tertinggi:")
# print(top_categories)

# """**Insight:**
# - cama_mesa_banho (perlengkapan tempat tidur, meja, dan kamar mandi) menjadi kategori dengan penjualan tertinggi, yaitu sebanyak 12,695 item. Hal ini menunjukkan permintaan yang sangat tinggi untuk produk rumah tangga yang terkait dengan kenyamanan.
# - Kategori seperti moveis_decoracao (furniture dan dekorasi) dan beleza_saude (kecantikan dan kesehatan) berada di posisi kedua dan ketiga. Hal ini dapat dijadikan peluang untuk memperluas penawaran atau meningkatkan promosi di sektor-sektor ini.
# - Kategori seperti utilidades_domesticas (peralatan rumah tangga) menunjukkan penjualan yang stabil dengan 7,949 item terjual.
# Kategori ini dapat diandalkan untuk memberikan pendapatan berkelanjutan dengan promosi rutin.

# ### Pertanyaan 2: Apa pola ulasan pelanggan terhadap pesanan dengan nilai bintang rendah?
# """

# # Filter Ulasan dengan Skor Rendah
# low_score_reviews = cleaned_reviews_df[cleaned_reviews_df['review_score'] <= 2].copy()

# # Menambahkan Kolom Panjang Komentar
# low_score_reviews.loc[:, 'comment_length'] = low_score_reviews['review_comment_message'].fillna('').apply(len)

# # Visualisasi Penyebaran Panjang Komentar
# plt.figure(figsize=(12, 6))
# sns.histplot(low_score_reviews['comment_length'], bins=30, kde=True, color='red')
# plt.title('Penyebaran Panjang Komentar untuk Ulasan Skor Rendah')
# plt.xlabel('Panjang Komentar')
# plt.ylabel('Frekuensi')
# plt.grid(axis='y', linestyle='--', alpha=0.7)
# plt.show()

# # Analisis Ketersediaan Komentar
# low_score_reviews.loc[:, 'has_comment'] = low_score_reviews['review_comment_message'].notna()

# # Visualisasi Ketersediaan Komentar
# plt.figure(figsize=(10, 6))
# sns.countplot(data=low_score_reviews, x='review_score')
# plt.title('Ketersediaan Komentar pada Ulasan Skor Rendah')
# plt.xlabel('Skor Ulasan')
# plt.ylabel('Jumlah Ulasan')
# plt.legend(title='Komentar Tersedia', labels=['Tidak Ada', 'Ada'])
# plt.grid(axis='y', linestyle='--', alpha=0.7)
# plt.show()

# # Penyebaran Ulasan Skor Rendah Berdasarkan Panjang Komentar
# low_score_reviews.loc[:, 'comment_length_category'] = pd.cut(
#     low_score_reviews['comment_length'],
#     bins=[0, 50, 150, 300, 1000],
#     labels=['Sangat Pendek', 'Pendek', 'Sedang', 'Panjang']
# )

# # Visualisasi Penyebaran Kategori Panjang Komentar
# plt.figure(figsize=(12, 6))
# sns.countplot(
#     data=low_score_reviews,
#     x='comment_length_category',
#     order=['Sangat Pendek', 'Pendek', 'Sedang', 'Panjang']
# )
# plt.title('Penyebaran Kategori Panjang Komentar untuk Ulasan Skor Rendah')
# plt.xlabel('Kategori Panjang Komentar')
# plt.ylabel('Jumlah')
# plt.grid(axis='y', linestyle='--', alpha=0.7)
# plt.show()

# # Hubungan Antara Panjang Komentar dan Skor Ulasan
# plt.figure(figsize=(10, 6))
# sns.boxplot(
#     data=low_score_reviews,
#     x='review_score',
#     y='comment_length',
# )
# plt.title('Hubungan Panjang Komentar dan Skor Ulasan Rendah')
# plt.xlabel('Skor Ulasan')
# plt.ylabel('Panjang Komentar')
# plt.grid(axis='y', linestyle='--', alpha=0.7)
# plt.show()

# """**Insight:**
# - Pelanggan sering memberikan ulasan singkat untuk menyatakan ketidakpuasan mereka.
# - Skor ulasan rendah dengan komentar panjang sering kali mencerminkan masalah yang lebih serius, karena pelanggan meluangkan waktu untuk menjelaskan pengalaman negatif mereka.

# ### Pertanyaan 3:  Siapa saja penjual dengan performa terbaik berdasarkan jumlah penjualan?
# """

# # Menghitung Total Jumlah Item Terjual per Penjual
# seller_sales = cleaned_order_items_df.groupby('seller_id')['order_item_id'].count().reset_index()
# seller_sales.rename(columns={'order_item_id': 'total_items_sold'}, inplace=True)

# seller_performance = seller_sales.merge(sellers_df, on='seller_id')
# top_sellers = seller_performance.sort_values('total_items_sold', ascending=False).head(10)

# print("Top 10 Penjual dengan Performa Terbaik:")
# print(top_sellers[['seller_id', 'total_items_sold', 'seller_city', 'seller_state']])

# # Visualisasi Penjual Terbaik
# plt.figure(figsize=(12, 6))
# sns.barplot(data=top_sellers, x='seller_id', y='total_items_sold')
# plt.title('Top 10 Penjual dengan Performa Terbaik berdasarkan Jumlah Penjualan')
# plt.xlabel('ID Penjual')
# plt.ylabel('Total Jumlah Item Terjual')
# plt.xticks(rotation=45)
# plt.show()

# # Visualisasi Penyebaran Penjual Berdasarkan Kota
# plt.figure(figsize=(12, 6))
# sns.countplot(data=seller_performance, y='seller_city', order=seller_performance['seller_city'].value_counts().head(10).index)
# plt.title('Penyebaran Penjual Berdasarkan Kota')
# plt.xlabel('Jumlah Penjual')
# plt.ylabel('Kota')
# plt.show()

# # Visualisasi Penyebaran Penjual Berdasarkan Provinsi
# plt.figure(figsize=(12, 6))
# sns.countplot(data=seller_performance, y='seller_state', order=seller_performance['seller_state'].value_counts().head(10).index)
# plt.title('Penyebaran Penjual Berdasarkan Provinsi')
# plt.xlabel('Jumlah Penjual')
# plt.ylabel('Provinsi')
# plt.show()

# """**Insight:**
# - Penjual dengan ID 6560211a19b47992c3666cc44a7e94c0 adalah penjual dengan performa terbaik berdasarkan jumlah item yang terjual (1,975 item).
# - 10 besar penjual memiliki total penjualan yang signifikan, yatu berkisar antara 1.046 hingga 1.975 item. Hal ini menunjukkan konsistensi dalam menarik pelanggan dan mempertahankan volume penjualan tinggi.
# - Negara bagian SP (Sao Paulo) mendominasi jumlah penjual. Hal ini tidak hanya mencerminkan dominasi ekonomi wilayah ini, tetapi juga kemudahan akses terhadap layanan e-commerce.
# - Kota-kota lain, meskipun lebih kecil jumlahnya, seperti Santo Andre atau Sao Jose do Rio Preto, masih menunjukkan kontribusi signifikan terhadap penjualan.

# ## Analisis Lanjutan (Opsional)

# ###Analisis RFM (Recency, Frequency, Monetary)
# """

# # Menghitung Tanggal Terakhir Pembelian
# latest_order_date = orders_df['order_purchase_timestamp'].max()

# # Membuat metrik RFM
# rfm = customers_df.merge(orders_df, on='customer_id').merge(order_items_df, on='order_id')

# # Recency
# rfm['order_purchase_timestamp'] = pd.to_datetime(rfm['order_purchase_timestamp'])
# rfm['recency'] = (latest_order_date - rfm['order_purchase_timestamp']).dt.days

# # Frequency
# rfm_frequency = rfm.groupby('customer_unique_id')['order_id'].nunique().reset_index()
# rfm_frequency.rename(columns={'order_id': 'frequency'}, inplace=True)

# # Monetary
# rfm_monetary = rfm.groupby('customer_unique_id')['price'].sum().reset_index()
# rfm_monetary.rename(columns={'price': 'monetary'}, inplace=True)

# # Menggabungkan RFM
# rfm_combined = rfm[['customer_unique_id', 'recency']].drop_duplicates()
# rfm_combined = rfm_combined.merge(rfm_frequency, on='customer_unique_id').merge(rfm_monetary, on='customer_unique_id')

# # Normalisasi RFM
# scaler = MinMaxScaler()
# rfm_combined[['recency', 'frequency', 'monetary']] = scaler.fit_transform(rfm_combined[['recency', 'frequency', 'monetary']])

# # Segmentasi Berdasarkan Kuantil dengan Validasi
# def segment_metric(metric, q=4):
#     try:
#         return pd.qcut(metric, q=q, labels=range(1, q + 1), duplicates='drop')
#     except ValueError:
#         # Fallback jika data tidak cukup bervariasi
#         return pd.cut(metric, bins=q, labels=range(1, q + 1), include_lowest=True)

# rfm_combined['R_segment'] = segment_metric(rfm_combined['recency'], 4)
# rfm_combined['F_segment'] = segment_metric(rfm_combined['frequency'], 4)
# rfm_combined['M_segment'] = segment_metric(rfm_combined['monetary'], 4)

# # Menghitung Skor RFM
# rfm_combined['RFM_score'] = rfm_combined['R_segment'].astype(int) + rfm_combined['F_segment'].astype(int) + rfm_combined['M_segment'].astype(int)

# # Menentukan Segmentasi Pelanggan
# def assign_segment(score):
#     if score >= 9:
#         return 'Best Customers'
#     elif score >= 6:
#         return 'Loyal Customers'
#     elif score >= 3:
#         return 'Potential Customers'
#     else:
#         return 'At Risk'

# rfm_combined['customer_segment'] = rfm_combined['RFM_score'].apply(assign_segment)

# # Analisis Segmentasi Pelanggan
# segment_analysis = rfm_combined.groupby('customer_segment').agg({
#     'recency': 'mean',
#     'frequency': 'mean',
#     'monetary': 'mean',
#     'customer_unique_id': 'count'
# }).rename(columns={'customer_unique_id': 'customer_count'}).reset_index()

# # Visualisasi Distribusi RFM Metrics
# plt.figure(figsize=(12, 6))
# sns.histplot(rfm_combined['recency'], bins=30, kde=True, color='blue', label='Recency')
# sns.histplot(rfm_combined['frequency'], bins=30, kde=True, color='green', label='Frequency')
# sns.histplot(rfm_combined['monetary'], bins=30, kde=True, color='orange', label='Monetary')
# plt.title('Distribusi RFM Metrics')
# plt.xlabel('Nilai')
# plt.ylabel('Jumlah')
# plt.legend()
# plt.show()

# # Visualisasi Pie Chart Segmentasi Pelanggan
# segment_counts = rfm_combined['customer_segment'].value_counts()

# plt.figure(figsize=(8, 8))
# plt.pie(segment_counts, labels=segment_counts.index, autopct='%1.1f%%', startangle=140, colors=['gold', 'lightblue', 'lightgreen', 'salmon'])
# plt.title('Distribusi Segmen Pelanggan')
# plt.show()

# # Visualisasi Korelasi antar Metrik RFM
# correlation_matrix = rfm_combined[['recency', 'frequency', 'monetary']].corr()
# plt.figure(figsize=(8, 6))
# sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt='.2f')
# plt.title('Korelasi antar Metrik RFM')
# plt.show()

# # Clustering dengan K-Means
# wcss = []
# for i in range(1, 11):
#     kmeans = KMeans(n_clusters=i, random_state=42)
#     kmeans.fit(rfm_combined[['recency', 'frequency', 'monetary']])
#     wcss.append(kmeans.inertia_)

# # Visualisasi Elbow Method
# plt.plot(range(1, 11), wcss, marker='o')
# plt.title('Elbow Method untuk Menentukan Cluster')
# plt.xlabel('Jumlah Cluster')
# plt.ylabel('WCSS')
# plt.show()

# # Menentukan Cluster
# optimal_clusters = 4
# kmeans = KMeans(n_clusters=optimal_clusters, random_state=42)
# rfm_combined['cluster'] = kmeans.fit_predict(rfm_combined[['recency', 'frequency', 'monetary']])

# # Visualisasi Cluster
# plt.figure(figsize=(12, 8))
# sns.scatterplot(data=rfm_combined, x='recency', y='monetary', hue='cluster', palette='viridis')
# plt.title('Cluster Pelanggan berdasarkan RFM')
# plt.xlabel('Recency')
# plt.ylabel('Monetary')
# plt.legend()
# plt.show()

# # Hasil RFM Analysis
# print("Hasil Deskriptif RFM:")
# print(rfm_combined.describe())

# print("\nAnalisis Segmentasi Pelanggan:")
# print(segment_analysis)

# """**Insight:**
# - Mengelompokkan pelanggan ke dalam 4 segmen utama berdasarkan skor RFM, yaitu Best Customers (Skor RFM ≥ 9), Loyal Customers (6 ≤ Skor RFM < 9), Potential Customers (3 ≤ Skor RFM < 6), dan At Risk (di bawah 3).
# - Sebagian besar pelanggan adalah low-frequency buyers yang membutuhkan strategi untuk meningkatkan frekuensi transaksi dan nilai pembelian.
# - Korelasi antara Frequency dan Monetary tinggi. Hal ini menunjukkan pelanggan dengan frekuensi pembelian tinggi cenderung menghasilkan nilai monetari yang lebih besar.
# - Recency memiliki korelasi negatif dengan Frequency dan Monetary. Hal ini menunjukkan pelanggan yang baru saja bertransaksi cenderung lebih aktif dan bernilai lebih tinggi.
# - Cluster terbaik (Cluster 3) berisi pelanggan dengan nilai Monetary dan Frequency tinggi. Maka, dapat difokuskan untuk meningkatkan lifetime value pelanggan.
# - Cluster terendah (Cluster 0) mencakup pelanggan dengan nilai RFM rendah yang menunjukkan potensi churn. Maka, dapat diterapkan strategi re-engagement.

# ###Analisis Geospatial
# """

# # Membuat DataFrame untuk lokasi pelanggan
# customer_locations = customers_df.merge(geoloc_df, left_on='customer_zip_code_prefix', right_on='geolocation_zip_code_prefix')

# # Memilih hanya kolom penting
# customer_locations = customer_locations[['customer_unique_id', 'geolocation_lat', 'geolocation_lng']]

# # Visualisasi Distribusi Pelanggan di Peta
# plt.figure(figsize=(12, 8))
# plt.scatter(customer_locations['geolocation_lng'], customer_locations['geolocation_lat'], alpha=0.5, c='blue', s=10, label='Pelanggan')
# plt.title('Distribusi Pelanggan di Peta')
# plt.xlabel('Longitude')
# plt.ylabel('Latitude')
# plt.legend()
# plt.grid(True)
# plt.show()

# Judul Aplikasi
st.title("Analisis Data E-Commerce di Brasil")
st.write("Proyek ini menganalisis data e-commerce untuk memberikan insight bisnis.")

# Sidebar untuk navigasi
st.sidebar.title("Navigasi")
pages = ["Data Wrangling", "EDA", "RFM Analysis", "Visualisasi"]
page_choice = st.sidebar.radio("Pilih Halaman:", pages)

# Fungsi untuk memuat dataset
# @st.cache
def load_data():
    order_items_df = pd.read_csv("dataset/order_items_dataset.csv")
    products_df = pd.read_csv("dataset/products_dataset.csv")
    reviews_df = pd.read_csv("dataset/order_reviews_dataset.csv")
    sellers_df = pd.read_csv("dataset/sellers_dataset.csv")
    orders_df = pd.read_csv("dataset/orders_dataset.csv")
    geoloc_df = pd.read_csv("dataset/geolocation_dataset.csv")
    customers_df = pd.read_csv("dataset/customers_dataset.csv")
    payments_df = pd.read_csv("dataset/order_payments_dataset.csv")
    return (order_items_df, products_df, reviews_df, sellers_df, orders_df, geoloc_df, customers_df, payments_df)

order_items_df, products_df, reviews_df, sellers_df, orders_df, geoloc_df, customers_df, payments_df = load_data()

# Fungsi untuk pembersihan data
@st.cache
def clean_data(order_items_df, products_df, reviews_df, sellers_df, orders_df, geoloc_df, customers_df, payments_df):
    # Pembersihan order_items_df
    Q1_price = order_items_df['price'].quantile(0.25)
    Q3_price = order_items_df['price'].quantile(0.75)
    IQR_price = Q3_price - Q1_price

    Q1_fr = order_items_df['freight_value'].quantile(0.25)
    Q3_fr = order_items_df['freight_value'].quantile(0.75)
    IQR_fr = Q3_fr - Q1_fr

    order_items_df = order_items_df[
        (order_items_df['price'] >= (Q1_price - 1.5 * IQR_price)) &
        (order_items_df['price'] <= (Q3_price + 1.5 * IQR_price)) &
        (order_items_df['freight_value'] >= (Q1_fr - 1.5 * IQR_fr)) &
        (order_items_df['freight_value'] <= (Q3_fr + 1.5 * IQR_fr))
    ]

    # Pembersihan products_df
    products_df['product_category_name'] = products_df['product_category_name'].fillna('unknown')
    important_columns = ['product_weight_g', 'product_length_cm', 'product_height_cm', 'product_width_cm']
    products_df = products_df.dropna(subset=important_columns)

    # Pembersihan reviews_df
    reviews_df[['review_comment_title', 'review_comment_message']] = reviews_df[['review_comment_title', 'review_comment_message']].fillna('')

    # Pembersihan orders_df
    orders_df['order_status'] = orders_df['order_status'].fillna("unknown")
    date_col = [
        'order_purchase_timestamp',
        'order_approved_at',
        'order_delivered_carrier_date',
        'order_delivered_customer_date',
        'order_estimated_delivery_date'
    ]
    for col in date_col:
        orders_df[col] = pd.to_datetime(orders_df[col], errors='coerce')
        orders_df[col] = orders_df[col].fillna(pd.Timestamp("1970-01-01"))

    # Pembersihan geoloc_df
    geoloc_df = geoloc_df.drop_duplicates()

    # Pembersihan payments_df
    Q1_payment = payments_df['payment_value'].quantile(0.25)
    Q3_payment = payments_df['payment_value'].quantile(0.75)
    IQR_payment = Q3_payment - Q1_payment
    payments_df = payments_df[
        (payments_df['payment_value'] >= (Q1_payment - 1.5 * IQR_payment)) &
        (payments_df['payment_value'] <= (Q3_payment + 1.5 * IQR_payment))
    ]

    return order_items_df, products_df, reviews_df, sellers_df, orders_df, geoloc_df, customers_df, payments_df

order_items_df, products_df, reviews_df, sellers_df, orders_df, geoloc_df, customers_df, payments_df = clean_data(
    order_items_df, products_df, reviews_df, sellers_df, orders_df, geoloc_df, customers_df, payments_df
)

# Tampilan halaman "Data Wrangling"
if page_choice == "Data Wrangling":
    st.subheader("Data Wrangling")
    st.write("### Dataset: Order Items")
    st.dataframe(order_items_df.head())
    st.write("### Informasi Data:")
    buffer = []
    order_items_df.info(buf=buffer)
    info_str = "\n".join(buffer)
    st.text(info_str)

# Halaman "EDA"
elif page_choice == "EDA":
    st.subheader("Exploratory Data Analysis (EDA)")

    # Visualisasi Distribusi Harga
    st.write("### Distribusi Harga Produk")
    fig, ax = plt.subplots()
    sns.histplot(order_items_df['price'], bins=30, kde=True, ax=ax)
    ax.set_title("Distribusi Harga Produk")
    ax.set_xlabel("Harga")
    ax.set_ylabel("Frekuensi")
    st.pyplot(fig)

    # Visualisasi Kategori Produk
    st.write("### Jumlah Produk per Kategori")
    product_counts = products_df['product_category_name'].value_counts()
    fig = px.bar(product_counts, x=product_counts.index, y=product_counts.values, labels={'x': 'Kategori', 'y': 'Jumlah'})
    st.plotly_chart(fig)

# Halaman "RFM Analysis"
elif page_choice == "RFM Analysis":
    st.subheader("Analisis RFM (Recency, Frequency, Monetary)")

    latest_order_date = pd.to_datetime(orders_df['order_purchase_timestamp']).max()
    orders_df['order_purchase_timestamp'] = pd.to_datetime(orders_df['order_purchase_timestamp'])
    rfm = customers_df.merge(orders_df, on='customer_id').merge(order_items_df, on='order_id')

    rfm['recency'] = (latest_order_date - rfm['order_purchase_timestamp']).dt.days
    rfm_frequency = rfm.groupby('customer_unique_id')['order_id'].nunique().reset_index()
    rfm_frequency.rename(columns={'order_id': 'frequency'}, inplace=True)
    rfm_monetary = rfm.groupby('customer_unique_id')['price'].sum().reset_index()
    rfm_monetary.rename(columns={'price': 'monetary'}, inplace=True)

    st.write("### Distribusi RFM Metrics")
    fig, ax = plt.subplots()
    sns.histplot(rfm_frequency['frequency'], bins=20, kde=True, ax=ax, label='Frequency', color='green')
    sns.histplot(rfm_monetary['monetary'], bins=20, kde=True, ax=ax, label='Monetary', color='orange')
    ax.legend()
    st.pyplot(fig)

# Halaman "Visualisasi"
elif page_choice == "Visualisasi":
    st.subheader("Visualisasi Data")
    st.write("### Word Cloud untuk Komentar Ulasan")
    comment_txt = " ".join(reviews_df['review_comment_message'].dropna())
    wordcloud = WordCloud(width=800, height=400, background_color='white').generate(comment_txt)
    plt.figure(figsize=(10, 5))
    plt.imshow(wordcloud, interpolation='bilinear')
    plt.axis('off')
    st.pyplot(plt)

    st.write("### Distribusi Lokasi Pelanggan")
    fig = px.scatter_geo(geoloc_df, lat='geolocation_lat', lon='geolocation_lng', opacity=0.4)
    st.plotly_chart(fig)

st.sidebar.info("Gunakan menu di atas untuk menjelajahi analisis.")

"""**Insight:**
- Titik-titik yang lebih padat pada peta menunjukkan area dengan konsentrasi pelanggan yang lebih tinggi. Lokasi ini bisa menjadi indikasi bahwa area tersebut memiliki permintaan yang lebih besar atau lebih banyak pelanggan yang melakukan pembelian.

## Conclusion

Berdasarkan analisis data e-commerce di Brazil, beberapa kesimpulan penting dapat diambil untuk mendukung pengambilan keputusan strategis.

##1. Kategori Produk dengan Penjualan Tertinggi
Berdasarkan hasil analisis, terdapat kategori produk tertentu yang memiliki jumlah penjualan tertinggi. Informasi ini dapat dimanfaatkan untuk mengoptimalkan stok dan strategi pemasaran pada kategori tersebut.

##2. Pola Ulasan Pelanggan
Pola ulasan menunjukkan adanya bias pada skor ulasan pelanggan yang cenderung tinggi. Namun, ulasan dengan nilai rendah seringkali memberikan informasi yang lebih mendetail mengenai kekurangan produk atau layanan. Hal ini menunjukkan pentingnya meninjau ulasan rendah untuk perbaikan layanan.

##3. Performa Penjual Terbaik
Penjual dengan performa terbaik diidentifikasi berdasarkan jumlah penjualan mereka. Pengetahuan ini dapat membantu perusahaan dalam merancang program loyalitas atau kolaborasi khusus dengan penjual yang berkontribusi besar terhadap penjualan keseluruhan.

##4. Analisis Geospasial
Pemanfaatan analisis geospasial mengungkapkan area dengan konsentrasi pelanggan yang tinggi. Area ini berpotensi untuk menjadi fokus strategi pemasaran dan pengembangan layanan logistik yang lebih baik.
"""
